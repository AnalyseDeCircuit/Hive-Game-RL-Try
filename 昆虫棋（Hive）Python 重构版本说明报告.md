# 昆虫棋（Hive）Python 重构版本说明报告

## 1. 项目概述与结构

本项目是将原有的C++昆虫棋游戏（无UI版本）重构为Python语言实现。重构的目标是在保持原有游戏逻辑和功能不变的前提下，提供一个更易于理解、修改和扩展的Python版本。Python版本的代码结构清晰，模块化程度高，为后续的功能扩展（如人机对战、AI训练等）奠定了基础。

### 1.1 项目目标

*   将C++昆虫棋游戏的核心逻辑完整迁移至Python。
*   保持游戏规则、棋子行为和胜负判断与原C++版本一致。
*   优化代码结构，提高可读性和可维护性。
*   为未来的功能扩展（如图形界面、AI集成）提供良好的基础。

### 1.2 项目结构

重构后的Python项目主要包含以下几个模块（文件）：

*   `main.py`：游戏的入口文件，负责主菜单的显示、游戏流程的控制以及玩家输入的处理。
*   `game.py`：定义 `Game` 类，管理整个游戏的生命周期，包括游戏初始化、回合管理、玩家切换、胜负判断等。
*   `board.py`：定义 `ChessBoard` 类，负责棋盘的表示、棋子的放置、移动、以及棋盘状态的查询（如相邻棋子、被包围状态等）。
*   `player.py`：定义 `Player` 类，表示游戏中的玩家，管理玩家的棋子手牌、放置和移动棋子的逻辑。
*   `piece.py`：定义 `Piece` 及其子类（如 `QueenBee`, `Beetle`, `Spider`, `Ant`, `Grasshopper`, `Ladybug`, `Mosquito`, `Pillbug`），每个子类实现对应棋子的特定移动规则和特殊能力。
*   `utils.py`：包含游戏中使用的一些常量和枚举类型，如棋盘大小、方向向量、棋子类型ID等。
*   `requirements.txt`：列出项目所需的Python依赖库。

### 1.3 模块间关系

*   `main.py` 依赖 `game.py` 来控制游戏流程。
*   `game.py` 依赖 `board.py` 来操作棋盘，依赖 `player.py` 来管理玩家，并依赖 `piece.py` 中的棋子类型。
*   `player.py` 依赖 `board.py` 来执行棋子放置和移动操作，并依赖 `utils.py` 中的棋子类型定义。
*   `board.py` 依赖 `piece.py` 来创建和管理棋子实例，并依赖 `utils.py` 中的棋盘尺寸和方向定义。
*   `piece.py` 依赖 `utils.py` 来获取棋子类型ID。

这种模块化的设计使得每个部分职责明确，便于单独测试和维护，也为后续的扩展提供了便利。



## 2. 核心类实现细节

### 2.1 `Game` 类 (game.py)

`Game` 类是整个游戏的核心控制器，采用单例模式设计，确保游戏中只有一个 `Game` 实例。它负责协调 `Player` 和 `ChessBoard` 之间的交互。

**主要职责：**
*   **初始化与重置游戏**：`initialize_game` 方法负责设置玩家名称、初始化棋盘和玩家手牌，并确定起始玩家。`restart_game` 方法则用于重新开始一局游戏。
*   **回合管理**：`play_turn` 方法处理每个玩家的回合逻辑，包括接收玩家动作（放置或移动棋子）、执行动作、检查游戏状态（胜负或平局）并切换玩家。
*   **胜负判断**：`check_game_over` 方法根据游戏规则判断游戏是否结束，主要通过检查双方蜂后是否被完全包围来确定胜负或平局。
*   **玩家切换**：`switch_player` 方法在回合结束后切换当前玩家，并更新回合计数。
*   **显示**：调用 `board` 和 `player` 的方法来显示棋盘和玩家手牌信息。

**关键实现：**
*   **单例模式**：通过 `__new__` 方法实现，确保 `Game` 类只有一个实例，方便全局访问和状态管理。
*   **游戏流程控制**：`play_turn` 方法是游戏的核心循环，它根据玩家输入调用相应的放置或移动逻辑，并处理可能发生的错误。
*   **胜负逻辑**：`check_game_over` 方法遍历棋盘查找蜂后位置，并调用 `ChessBoard` 的 `is_position_surrounded` 方法来判断蜂后是否被包围。

### 2.2 `ChessBoard` 类 (board.py)

`ChessBoard` 类表示游戏的棋盘，负责管理棋子在棋盘上的位置和堆叠情况。它也采用单例模式。

**主要职责：**
*   **棋盘表示**：使用一个三维列表 `self.board: List[List[List[Piece]]]` 来表示棋盘。`board[x][y]` 是一个列表，用于存储堆叠在该位置的棋子，列表的最后一个元素代表最顶层的棋子。
*   **棋子放置**：`place_piece` 方法负责将棋子放置到指定位置。它会检查坐标是否越界，并根据棋子类型（例如，甲虫可以堆叠）处理放置逻辑。
*   **棋子移动**：`move_piece` 方法负责将棋子从一个位置移动到另一个位置。它会验证移动的合法性（包括棋子所有权、移动规则等），然后更新棋盘状态。
*   **棋盘查询**：提供 `get_piece_at` (获取指定位置最顶层棋子)、`get_adjacent_pieces` (获取相邻棋子)、`has_adjacent_piece` (判断是否有相邻棋子) 和 `is_position_surrounded` (判断位置是否被包围) 等方法，支持游戏逻辑的判断。
*   **棋盘显示**：`display_board` 方法以文本形式打印当前棋盘状态，显示每个位置的棋子类型和所有者。

**关键实现：**
*   **三维列表**：巧妙地使用三维列表来模拟棋子的堆叠，特别是甲虫（Beetle）可以爬到其他棋子上的特性。
*   **相邻判断**：`DIRECTIONS` 常量定义了六个方向的偏移量，用于判断相邻位置。虽然棋盘是二维数组，但通过这六个方向的判断，模拟了六边形棋盘的相邻关系。
*   **移动验证**：`move_piece` 方法在执行移动前，会调用棋子自身的 `is_valid_move` 方法来验证移动是否符合该棋子的规则。

### 2.3 `Player` 类 (player.py)

`Player` 类表示游戏中的一个玩家，管理玩家的名称、手牌（剩余棋子数量）以及执行放置和移动棋子的操作。

**主要职责：**
*   **玩家信息**：存储玩家名称。
*   **手牌管理**：使用字典 `self.piece_count` 跟踪每种棋子的剩余数量。在初始化时，会根据是否使用DLC（下载内容）来设置初始棋子数量。
*   **放置棋子**：`place_piece` 方法负责从玩家手牌中移除一个棋子，并调用 `ChessBoard` 的方法将其放置到棋盘上。它会检查玩家是否有足够的棋子。
*   **移动棋子**：`move_piece` 方法负责调用 `ChessBoard` 的方法来移动棋子。它会检查蜂后是否已放置（游戏规则要求蜂后必须先放置才能移动其他棋子）。
*   **蜂后追踪**：`is_queen_bee_placed` 和 `queen_bee_position` 属性用于追踪玩家的蜂后是否已放置及其位置，这对于游戏规则（如蜂后必须先放置）和胜负判断至关重要。
*   **显示手牌**：`display_piece_count` 方法打印玩家当前剩余的棋子数量。

**关键实现：**
*   **独立手牌**：通过在 `__init__` 方法中使用 `dict(Player.DLC_PIECE_COUNT)` 或 `dict(Player.NO_DLC_PIECE_COUNT)` 来创建字典的副本，确保每个玩家拥有独立的手牌，避免了引用同一个字典导致的问题。
*   **蜂后规则**：强制要求玩家在移动其他棋子之前必须先放置蜂后。

### 2.4 `Piece` 类及其子类 (piece.py)

`piece.py` 文件定义了 `Piece` 抽象基类以及各种具体棋子的子类。每个子类都实现了其独特的移动规则。

**主要职责：**
*   **`Piece` 抽象基类**：定义了所有棋子共有的属性（如位置、所有者、类型）和抽象方法 `is_valid_move`。所有具体棋子类都必须继承 `Piece` 并实现 `is_valid_move` 方法。
*   **具体棋子类**：
    *   `QueenBee` (蜂后)：移动规则是每回合只能移动一格。
    *   `Beetle` (甲虫)：移动规则是每回合只能移动一格，并且可以爬到其他棋子上方。
    *   `Spider` (蜘蛛)：移动规则是每回合必须移动三格，不能少也不能多，并且不能改变方向。
    *   `Ant` (蚂蚁)：移动规则是每回合可以移动任意格数，但不能跳过棋子。
    *   `Grasshopper` (蚱蜢)：移动规则是跳过一条直线上的所有棋子，落在第一个空位上。
    *   `Ladybug` (瓢虫)：移动规则是移动三格，其中两格在棋子上方，最后一格落在空位上。
    *   `Mosquito` (蚊子)：特殊棋子，可以模仿相邻棋子的移动能力。
    *   `Pillbug` (鼠妇)：特殊棋子，可以移动相邻的棋子。

**关键实现：**
*   **多态性**：通过继承和方法重写，实现了不同棋子独特的移动逻辑，使得游戏逻辑清晰且易于扩展新的棋子类型。
*   **移动验证**：每个棋子类内部的 `is_valid_move` 方法封装了该棋子的所有移动规则，包括距离、路径、是否能跳过等。这些方法会与 `ChessBoard` 的查询方法（如 `get_piece_at`, `has_adjacent_piece`）协同工作，以确保移动的合法性。

### 2.5 `utils` 模块 (utils.py)

`utils.py` 模块是一个辅助模块，主要用于定义游戏中使用的常量和枚举类型。

**主要内容：**
*   `BOARD_SIZE`：定义棋盘的尺寸。
*   `DIRECTIONS`：定义了用于计算相邻位置的六个方向偏移量，模拟了六边形棋盘的相邻关系。
*   `PieceType`：一个枚举类，定义了所有棋子的类型ID，方便在代码中使用有意义的名称而不是数字来引用棋子类型。

**关键实现：**
*   **常量和枚举**：集中管理游戏中的重要常量和枚举，提高了代码的可读性和可维护性，避免了硬编码。

通过上述核心类的设计和实现，Python重构版本成功地复刻了C++版本昆虫棋的游戏逻辑，并提供了清晰、模块化的代码结构。



## 3. 用户交互与功能

重构后的Python昆虫棋游戏提供了基于命令行的用户交互界面，旨在模拟原始C++版本的功能。用户可以通过简单的文本输入来控制游戏流程和棋子操作。

### 3.1 主菜单功能

游戏启动后，会显示一个主菜单，提供以下选项：

*   **Start Game (开始游戏)**：进入游戏对战模式。在进入游戏前，会提示玩家输入各自的用户名。
*   **Exit Game (退出游戏)**：关闭游戏程序。

### 3.2 游戏内菜单与回合操作

进入游戏后，每个回合会显示当前棋盘状态、当前玩家手牌以及游戏内菜单：

*   **Play Turn (进行回合)**：允许当前玩家执行一个操作（放置棋子或移动棋子）。
*   **Restart Game (重新开始游戏)**：重新开始一局新的游戏，保留玩家名称。
*   **End Current Game (结束当前游戏)**：结束当前正在进行的游戏，返回主菜单。
*   **Return to Main Menu (返回主菜单)**：直接返回主菜单，不结束当前游戏。

### 3.3 棋子操作指令

在“Play Turn”选项中，玩家需要输入指令来执行棋子操作：

*   **P (Place) - 放置棋子**：
    *   输入格式：`P` (回车)
    *   随后提示输入：`x y piece_type` (回车)
        *   `x, y`：棋子放置的棋盘坐标。
        *   `piece_type`：棋子类型对应的数字ID（例如，0代表QueenBee，1代表Beetle等）。
    *   示例：`5 5 0` (在坐标(5,5)放置QueenBee)

*   **M (Move) - 移动棋子**：
    *   输入格式：`M` (回车)
    *   随后提示输入：`from_x from_y to_x to_y` (回车)
        *   `from_x, from_y`：棋子当前所在的棋盘坐标。
        *   `to_x, to_y`：棋子目标移动的棋盘坐标。
    *   随后提示输入：`piece_name` (回车)
        *   `piece_name`：要移动的棋子的英文名称（例如，QueenBee, Beetle等）。
    *   示例：`5 5 6 6` (将(5,5)的棋子移动到(6,6))，然后输入 `QueenBee`。

### 3.4 错误处理与提示

游戏对玩家的输入进行了基本的验证和错误处理。当玩家输入无效指令、尝试非法移动或放置棋子时，系统会打印相应的错误信息，并提示玩家重新输入，以确保游戏的正常进行。

### 3.5 国际化（英文支持）

根据用户要求，所有用户可见的输入提示、菜单选项和游戏信息都已转换为英文，以提供更广泛的适用性。

### 3.6 游戏状态显示

每个回合开始时，游戏会清晰地显示当前的回合数、当前玩家的名称、玩家手牌中剩余的棋子数量，以及当前棋盘的布局。棋盘上的棋子以其类型首字母和所有者首字母（例如 `QP` 代表Player的QueenBee）表示，空位以 `.` 表示。

通过这些交互设计，重构后的Python昆虫棋游戏在命令行环境下提供了完整且友好的游戏体验，忠实地再现了原C++版本的功能。

